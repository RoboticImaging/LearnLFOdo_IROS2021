# This script plots the trajectories generated by the different methods
#
# Author and Maintainer: Tejaswi Digumarti (tejaswi.digumarti@sydney.edu.au)

import numpy as np
import matplotlib.pyplot as plt
import utils
import quaternion
import os
# Input: Estimated Poses in a Text File with the format x y z rx ry rz


def convert_pose_to_tum(pose_abs, name):
    tum_pose = []
    for i in range(pose_abs.shape[0]):
        t = pose_abs[i, 0:3, 3].reshape(3,)
        rotmat = pose_abs[i, 0:3, 0:3].astype(np.double)
        quat = quaternion.as_float_array(quaternion.from_rotation_matrix(rotmat))
        tum_pose.append([i, t[0], t[1], t[2], quat[0], quat[1], quat[2], quat[3]])
    np.savetxt(name, tum_pose, delimiter=" ")

if __name__ == "__main__":
    seq = "40"
    run_name = "artemis_test_b16_interarea_tv_mean"
    data_dir = "/media/dtejaswi/DATA/CommonData/Projects/student_projects/joe_daniel/data/module-1-1/module1-2-png"
    checkpoint = 40
    model_dir = "/home/dtejaswi/tensorboard_hpc/" + run_name

    out_folder = os.path.join("/media/dtejaswi/DATA/CommonData/Projects/student_projects/joe_daniel/code",
                              "tum_poses", run_name)
    os.makedirs(out_folder, exist_ok=True)

    modes = ["singlewarp", "multiwarp-5"]
    enc_s = ['epi_without_disp_stack', 'epi', 'stack', 'focalstack-17-5', 'focalstack-17-9', 'monocular']
    enc_m = ['epi_without_disp_stack', 'epi', 'stack', 'focalstack-17-5', 'focalstack-17-9']
    # ground truth poses
    # these are all 4x4 matrices
    pose_gt_prev_curr_cam = np.load(os.path.join(data_dir, "seq" + seq + "/poses_gt_prev_curr_cam.npy"))
    pose_gt_first_cam = np.load(os.path.join(data_dir, "seq" + seq + "/poses_gt_first_cam.npy"))
    pose_gt_base_cam = np.load(os.path.join(data_dir, "seq" + seq + "/poses_gt_base_cam.npy"))
    # save files in tum format
    convert_pose_to_tum(pose_gt_first_cam, "../tum_poses/tum_gt_first_cam_" + seq + ".txt")


    for mode in modes:
        if mode == "singlewarp":
            encodings = enc_s
        else:
            encodings = enc_m

        for enc in encodings:
            # load the estimated poses
            # this for the old old training is in euler angles
            pose_file = os.path.join(model_dir, mode, enc, "results", "seq" + seq + "_epoch_" + str(checkpoint) + "/poses.npy")
            pose_est_prev_curr_cam_euler = np.load(pose_file)
            pose_est_prev_curr_cam = np.zeros((pose_est_prev_curr_cam_euler.shape[0], 4, 4), dtype=np.float)

            for i in range(pose_est_prev_curr_cam.shape[0]):
                pose_est_prev_curr_cam[i, :] = utils.get_4x4_from_pose(pose_est_prev_curr_cam_euler[i, :], rotation_mode="euler")

            # compute estimated poses wrt first pose
                pose_est_first_cam = utils.rel_to_abs(pose_est_prev_curr_cam)

            # # plot trajectories
            # fig = plt.figure()
            # ax = fig.add_subplot(111, projection='3d')
            #
            # # ground truth pose
            # ax.plot3D(pose_gt_first_cam[:, 0, 3], pose_gt_first_cam[:, 1, 3], pose_gt_first_cam[:, 2, 3], 'k')
            # for i in range(0, len(pose_gt_first_cam), 5):
            #     utils.draw_axes_at(pose_gt_first_cam[i, :], ax, scale=0.01, frame_label=i, arrowstyle='->')  # end effector wrt base
            #
            # # estimated pose
            # ax.plot3D(pose_est_first_cam[:, 0, 3], pose_est_first_cam[:, 1, 3], pose_est_first_cam[:, 2, 3], 'r')
            # for i in range(0, len(pose_est_first_cam), 5):
            #     utils.draw_axes_at(pose_est_first_cam[i, :], ax, scale=0.03, frame_label=i, arrowstyle='->')  # camera wrt base
            #
            # ax.set_xlabel("x")
            # ax.set_ylabel("y")
            # ax.set_zlabel("z")
            # # plt.show()


            output_file = os.path.join(out_folder, mode + "_" + enc + "_" + seq + "_tum_est_first_cam.txt")
            convert_pose_to_tum(pose_est_first_cam, output_file)